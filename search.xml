<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Docker-应用容器引擎</title>
      <link href="/post/5a3fc010.html"/>
      <url>/post/5a3fc010.html</url>
      
        <content type="html"><![CDATA[<h1 id="Docker简介"><a href="#Docker简介" class="headerlink" title="Docker简介"></a>Docker简介</h1><h2 id="Docker的目标是实现经量级的操作系统虚拟化解决方案"><a href="#Docker的目标是实现经量级的操作系统虚拟化解决方案" class="headerlink" title="Docker的目标是实现经量级的操作系统虚拟化解决方案"></a>Docker的目标是实现经量级的操作系统虚拟化解决方案</h2><h3 id="轻量级："><a href="#轻量级：" class="headerlink" title="轻量级："></a>轻量级：</h3><p>与传统的虚拟机相比，docker是一个更轻量级的虚拟化技术</p><p>也就是说docker本身是一个软件，但是我们可以使用这个软件安装各种其他软件</p><p>比如linux、mysql、tomcat。。。。</p><p><strong>与重量级区别：传统虚拟机需要下载安装指定软件的完整版本</strong></p><p>比如我们要安装一个linux版本的mysql</p><p>那么传统的虚拟机就必须先安装一个完成的linux系统再下载安装一个完整的mysql</p><p>但是使用docker直接就下载安装mysql就行了，docker会自动的将mysql需要的linux系统的核心部分下载</p><h3 id="操作系统虚拟化"><a href="#操作系统虚拟化" class="headerlink" title="操作系统虚拟化"></a>操作系统虚拟化</h3><p>docker不需要安装一个额外的完整的操作系统</p><h2 id="Docker的底层原理"><a href="#Docker的底层原理" class="headerlink" title="Docker的底层原理"></a>Docker的底层原理</h2><h3 id="Docker是如何工作的"><a href="#Docker是如何工作的" class="headerlink" title="Docker是如何工作的"></a>Docker是如何工作的</h3><p>Docker是一个Client-Server结构的系统，Docker守护进程运行在主机上， 然后通过Socket连接从客户端访问，守护进程从客户端接受命令并管理运行在主机上的容器。 容器，是一个运行时环境，就是我们前面说到的集装箱。</p><p><img src="https://raw.githubusercontent.com/quhuiya/properties/main/imgclip_image001.png" alt="img"> </p><h3 id="LXC-容器技术-："><a href="#LXC-容器技术-：" class="headerlink" title="LXC(容器技术)："></a>LXC(容器技术)：</h3><p>这是DOCKER的核心思想</p><p>Docker的基础是Linux容器（LXC）等技术。在LXC的基础上Docker进行了进一步的封装，让用户不需要关心容器的管理，使得操作更加简单。</p><h3 id="容器技术的好处"><a href="#容器技术的好处" class="headerlink" title="容器技术的好处"></a>容器技术的好处</h3><p>1.每一个容器中都可以安装自己的软件</p><p>2.所有容器之间是互相隔离的</p><p>3.容器之间可以共享组件</p><p>比如a容器安装了tomcat9 ， tomcat9依赖于jdk，后面在b容器需要安装tomcat10, tomcat10也依赖jdk,就直接使用之前下载好的jdk</p><p><strong>用户操作Docker的容器就像操作一个快速轻量级的虚拟机一样简单</strong></p><p>docker将对容器的操作封装成了很多很简洁的命令供我们使用</p><h2 id="为什么要使用docker"><a href="#为什么要使用docker" class="headerlink" title="为什么要使用docker"></a>为什么要使用docker</h2><ul><li>docker启动速度非常的快 ,是秒级的，传统虚拟机启动速度是分钟级</li><li>Docker 对系统资源的利用率很高，一台主机上可以同时运行数千个Docker 容器</li><li>更快的部署 使用docker部署一个全新的环境速度非常高</li><li>更轻松的迁移 因为每一个容器中包含了需要的操作系统的核心部分，所以如果要迁移其他的操作系统的服务 器中，对容器是完全没有影响的</li><li>更方便的管理<br>​ docker设计很方便的操作容器的命令</li></ul><h1 id="Docker的安装与配置"><a href="#Docker的安装与配置" class="headerlink" title="Docker的安装与配置"></a>Docker的安装与配置</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><blockquote><p>注意：必须使用sentos7以上的版本</p><ul><li>使用此命令查看</li><li><strong>cat &#x2F;etc&#x2F;redhat-release</strong></li></ul></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 安装docker</span><br><span class="line">yum install -y docker</span><br><span class="line"># 启动docker</span><br><span class="line">systemctl start docker</span><br><span class="line"># 设置docker开机自启</span><br><span class="line">systemctl enable docker</span><br><span class="line"># 查看docker版本</span><br><span class="line">docker version</span><br></pre></td></tr></table></figure><h3 id="测试运行"><a href="#测试运行" class="headerlink" title="测试运行"></a>测试运行</h3><ol><li>从docker的远程仓库拉取hello-world镜像</li><li>运行该镜像生成一个hello-world容器</li></ol><p>镜像：静态的文件</p><p>容器：就是运行镜像文件而在内存生成的进程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker pull hello-world # 拉取镜像</span><br><span class="line">docker run hello-world  # 运行镜像生成容器</span><br></pre></td></tr></table></figure><h2 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop docker</span><br><span class="line">yum -y remove docker</span><br><span class="line">rm -rf /var/lib/docker</span><br></pre></td></tr></table></figure><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="docker加速配置"><a href="#docker加速配置" class="headerlink" title="docker加速配置"></a>docker加速配置</h3><p>我们默认拉取docker镜像的服务器在国外，为了更稳定建议设置阿里云镜像加速</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 进入配置文件</span></span><br><span class="line">vim /etc/docker/daemon.json</span><br><span class="line"><span class="comment">// 在文件中添加以下内容</span></span><br><span class="line">&#123; <span class="string">&quot;registry-mirrors&quot;</span>: [<span class="string">&quot;https://1thbhxhq.mirror.aliyuncs.com&quot;</span>] &#125;</span><br><span class="line"><span class="comment">// 重新加载配置文件</span></span><br><span class="line">systemctl daemon-reload</span><br><span class="line"><span class="comment">// 重启dockers</span></span><br><span class="line">systemctl restart docker</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h1><h2 id="镜像相关命令"><a href="#镜像相关命令" class="headerlink" title="镜像相关命令"></a>镜像相关命令</h2><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>docker images</td><td>查看所有的镜像</td></tr><tr><td>docker pull 镜像名称</td><td>拉取指定名称的镜像</td></tr><tr><td>docker rmi -f 镜像名称&#x2F;镜像id</td><td>强制删除指定镜像</td></tr><tr><td>docker rmi -f $(docker images -qa)</td><td>删除所有镜像。本质是使用子命令</td></tr><tr><td>docker search 镜像名称</td><td>到docker仓库查找指定名称的镜像</td></tr></tbody></table><h2 id="容器相关命令"><a href="#容器相关命令" class="headerlink" title="容器相关命令"></a>容器相关命令</h2><table><thead><tr><th align="left">命令</th><th>说明</th></tr></thead><tbody><tr><td align="left">docker run 镜像名称</td><td>运行指定容器  ；有以下参数：<br />–name     为运行的容器指定名称<br />-d              指定容器以后台形式运行<br />-it              以交互模式运行容器，并分配一个伪终端<br />-p              指定端口映射</td></tr><tr><td align="left">docker ps</td><td>查询所有运行中的主容器</td></tr><tr><td align="left">docker ps -a</td><td>查询 所有的容器包括没有运行的以及子容器</td></tr><tr><td align="left">docker rm -f 容器名称&#x2F;容器的id</td><td>强制删除指定的容器，如果有子容器一起干掉</td></tr><tr><td align="left">docker rm -f $(docker ps -qa）</td><td>删除所有的容器</td></tr><tr><td align="left">docker exec -it 容器名称&#x2F;容器id bash</td><td>进入指定的容器</td></tr><tr><td align="left">docker stop 容器名称&#x2F;容器id</td><td>停止指定的容器</td></tr><tr><td align="left">docker kill 容器名称&#x2F;容器id</td><td>强制停止指定的容器</td></tr><tr><td align="left">docker start 容器名称&#x2F;容器id</td><td>运行指定的容器</td></tr><tr><td align="left">docker restart 容器名称&#x2F;容器id</td><td>重启指定的容器</td></tr><tr><td align="left">docker logs 容器名称&#x2F;容器id</td><td>查看指定容器的日志</td></tr><tr><td align="left">docker top 容器名称&#x2F;容器id</td><td>查看容器运行的进程</td></tr><tr><td align="left">docker inspect 容器名称&#x2F;容器id</td><td>查看容器内部的所有细节</td></tr><tr><td align="left">docker cp 宿主机的文件路径 容器名称&#x2F;容器id:容器中的路径</td><td>将文件从宿主机复制到容器中</td></tr><tr><td align="left">docker cp 容器名称&#x2F;容器id:容器中的路径 宿主机的文件路径</td><td>将文件从容器中复制到宿主机</td></tr></tbody></table><h1 id="镜像详解"><a href="#镜像详解" class="headerlink" title="镜像详解"></a>镜像详解</h1><h2 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h2><p>镜像是一个使用了联合文件系统（UnionFS）的静态文件</p><h3 id="联合文件系统"><a href="#联合文件系统" class="headerlink" title="联合文件系统"></a>联合文件系统</h3><p>UnionFS（联合文件系统）：Union文件系统（UnionFS）是一种分层、轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下(unite several directories into a single virtual filesystem)。Union 文件系统是 Docker 镜像的基础。镜像可以通过分层来进行<strong>继承</strong>，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像。</p><h3 id="镜像的特点"><a href="#镜像的特点" class="headerlink" title="镜像的特点"></a>镜像的特点</h3><ul><li><p>镜像本身是只读的</p></li><li><p>但是在运行容器的时候，会在原镜像上面再套一层形成一个新的镜像</p></li></ul><blockquote><p>作用：用来对原镜像的内容进行修改</p><p>套的这一层一定在最外层，称之为<strong>容器层</strong></p><p>下面的就称之为<strong>镜像层</strong></p></blockquote><h1 id="自定义镜像"><a href="#自定义镜像" class="headerlink" title="自定义镜像"></a>自定义镜像</h1><p>问题一：镜像生成的容器更改内容后持久化</p><ul><li>当我们运行tomcat镜像后，往tomcat容器内添加项目，当我们删除容器后，通过镜像新创建的容器又需要重新添加项目</li></ul><p>问题二：多个容器需要进行数据共享</p><ul><li>运行mysql镜像后我们需要将数据库内容持久化。同时还需要将数据库提供给其他容器访问。</li></ul><p><strong>针对以上两个问题docker提供了对应的解决方法</strong></p><ul><li>commit：将整个容器保存为一个镜像文件，解决持久化问题</li><li>容器卷（挂载）：将容器内文件与宿主机文件建立联系（映射），修改容器内文件时宿主机被映射的文件也将更改</li></ul><h2 id="commit（生成镜像）"><a href="#commit（生成镜像）" class="headerlink" title="commit（生成镜像）"></a>commit（生成镜像）</h2><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit -m=&quot;新的镜像的说明&quot; -a=&quot;作者信息&quot; 容器名称/id 自定义新镜像的名称[:tag（版本号）]</span><br></pre></td></tr></table></figure><h3 id="通过tomcat测试"><a href="#通过tomcat测试" class="headerlink" title="通过tomcat测试"></a>通过tomcat测试</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 运行tomcat镜像</span></span><br><span class="line">docker run --name tomcat -p <span class="number">8080</span>:<span class="number">8080</span> -d tomcat <span class="comment">// 没有会自动拉取</span></span><br><span class="line"><span class="comment">// 将ROOT项目复制到tomcat容器的webapps目录中</span></span><br><span class="line">docker cp 宿主机的文件路径 容器名称/容器id:/usr/local/tomcat/webapps</span><br><span class="line"><span class="comment">// 将容器生成一个静态文件</span></span><br><span class="line">docker commit -m=<span class="string">&quot;有项目的tomcat&quot;</span> -a=<span class="string">&quot;xxx&quot;</span> 容器名称/id tomcat1:<span class="number">1.0</span></span><br><span class="line"><span class="comment">// 运行tomcat1镜像</span></span><br><span class="line">docker run --name tomcat1 -p <span class="number">8888</span>:<span class="number">8080</span> -d tomcat1 </span><br><span class="line"><span class="comment">// 启动浏览器访问</span></span><br></pre></td></tr></table></figure><blockquote><p>此方法不建议使用，每次更改都会产生一个新的镜像文件，麻烦。建议使用下文中的方式（数据卷）</p></blockquote><h2 id="容器数据卷"><a href="#容器数据卷" class="headerlink" title="容器数据卷"></a>容器数据卷</h2><p>可以指定容器中的任意目录或文件，将这个文件与宿主机的指定文件进行映射。</p><p>两个建立了映射的文件，无论其中某一个文件被更改，另一个文件都会有相同的操作，以保持两个文件的一致性</p><h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run   -v 宿主机文件路径:容器的数据卷的路径  镜像名称 </span><br></pre></td></tr></table></figure><h3 id="通过mysql测试"><a href="#通过mysql测试" class="headerlink" title="通过mysql测试"></a>通过mysql测试</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 运行mysql镜像</span></span><br><span class="line">docker run --name mysql -d -p <span class="number">3306</span>:<span class="number">3306</span> -e MYSQL_ROOT_PASSWORD=<span class="number">123456</span> -v /usr/local/mysql:/<span class="keyword">var</span>/lib/mysql mysql:<span class="number">5.7</span></span><br><span class="line"><span class="comment">// 通过数据库操作软件（navicat）进行链接：账号root，密码123456，</span></span><br><span class="line"><span class="comment">// 链接后新建内容并保存</span></span><br><span class="line"><span class="comment">// 关闭软件并删除容器</span></span><br><span class="line">docker rm -f mysql</span><br><span class="line"><span class="comment">// 重新运行镜像并链接查看刚才新建的数据是否存在</span></span><br><span class="line">docker run --name mysql -d -p <span class="number">3306</span>:<span class="number">3306</span> -e MYSQL_ROOT_PASSWORD=<span class="number">123456</span> -v /usr/local/mysql:/<span class="keyword">var</span>/lib/mysql mysql:<span class="number">5.7</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：当启动mysql指定挂载目录时无法启动（无挂载能正常启动）：在命令<strong>docker run</strong> <strong>后加上一个属性</strong>  –privileged&#x3D;true</p><p>原因为sentos7的安全模块未给权限</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --privileged=true --name mysql -d -p 3333:3306 -e MYSQL_ROOT_PASSWORD=123456 -v /usr/local/mysql:/var/lib/mysql mysql:5.7</span><br></pre></td></tr></table></figure></blockquote><h3 id="挂载的不同情况及结果"><a href="#挂载的不同情况及结果" class="headerlink" title="挂载的不同情况及结果"></a>挂载的不同情况及结果</h3><table><thead><tr><th>宿主机</th><th>容器</th><th>结果</th></tr></thead><tbody><tr><td>文件存在</td><td>文件不存在</td><td>挂载成功：复制过去</td></tr><tr><td>目录存在</td><td>目录不存在</td><td>挂载成功：复制目录及内容</td></tr><tr><td>——</td><td>——</td><td>——</td></tr><tr><td>文件存在</td><td>文件存在</td><td>挂载成功，容器内的文件内容被覆盖</td></tr><tr><td>目录存在</td><td>目录存在</td><td>挂载成功，容器内目录内容被覆盖</td></tr><tr><td>——</td><td>——</td><td>——</td></tr><tr><td>文件存在</td><td>目录存在</td><td>容器启动失败</td></tr><tr><td>目录存在</td><td>文件存在</td><td>容器启动失败</td></tr><tr><td>——</td><td>——</td><td>——</td></tr><tr><td>目录不存在</td><td>目录不存在</td><td>挂载成功，docker会自动在宿主机和容器内新建此目录</td></tr><tr><td>目录不存在</td><td>文件存在</td><td>容器启动失败</td></tr><tr><td>目录不存在</td><td>目录存在</td><td>挂载成功，容器内目录内容被覆盖（清空）</td></tr></tbody></table><h2 id="dockerfile的基本使用"><a href="#dockerfile的基本使用" class="headerlink" title="dockerfile的基本使用"></a>dockerfile的基本使用</h2><p>Dockerfile是用来构建Docker镜像的文件，是由一系列的命令和参数构成的脚本</p><p>也就是说我们可以通过Dockerfile编写相应的指令的方式来指定新的镜像由哪些内容组成，然后将该文件build成一个新的自定义镜像</p><h3 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -f 构建配置文件 -t 构建的镜像名称:版本 构建配置文件位置（到目录）</span><br></pre></td></tr></table></figure><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ul><li><strong>编写dockerfile</strong>（文件名固定）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 指定基础镜像</span><br><span class="line">FROM centos:7</span><br><span class="line"># 设置变量</span><br><span class="line">ENV ROOT_PATH /root/</span><br><span class="line"># 引用变量</span><br><span class="line">WORKDIR $ROOT_PATH</span><br><span class="line"># 执行指定命令</span><br><span class="line">RUN yum install -y vim</span><br><span class="line">CMD &quot;/bin/bash&quot;</span><br></pre></td></tr></table></figure><ul><li><strong>使用dockerfile构建新镜像</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -f dockerfile -t mycentos:1.0 .</span><br></pre></td></tr></table></figure><blockquote><p>注意，最有有一个小数点  表示指定当前目录</p></blockquote><ul><li><strong>运行新的镜像</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it mycentos:1.0</span><br></pre></td></tr></table></figure><ul><li><strong>测试</strong></li></ul><p>执行vim命令，发现有vim工具可使用了，说明新镜像构建成功</p>]]></content>
      
      
      <categories>
          
          <category> 软件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 容器 </tag>
            
            <tag> 虚拟化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>非关系型数据库-Redis的安装使用</title>
      <link href="/post/4c19db0b.html"/>
      <url>/post/4c19db0b.html</url>
      
        <content type="html"><![CDATA[<h1 id="NoSql非关系型数据库"><a href="#NoSql非关系型数据库" class="headerlink" title="NoSql非关系型数据库"></a>NoSql非关系型数据库</h1><p>Not Only Sql  不仅仅是sql</p><p>而sql是用来操作关系型数据库的，也就是说我们以后不仅仅要使用关系型数据库还要使用非关系型数据库</p><p>为什么要使用非关系型数据库：</p><p>我们实际开发的时候为了减轻关系型数据库的压力，可以使用非关系型数据库配合关系型数据库使用，基本都是用来作为关系型数据库的备份</p><h2 id="NoSql数据库类型"><a href="#NoSql数据库类型" class="headerlink" title="NoSql数据库类型"></a>NoSql数据库类型</h2><h3 id="键值型（Key-Value）数据库-Redis-x2F-Memcached"><a href="#键值型（Key-Value）数据库-Redis-x2F-Memcached" class="headerlink" title="键值型（Key-Value）数据库[Redis&#x2F;Memcached]"></a>键值型（Key-Value）数据库[Redis&#x2F;Memcached]</h3><p>适用场景：</p><p>储存用户信息，比如会话、配置文件、参数、购物车等等。这些信息一般都和ID（键）挂钩，这种情景下键值数据库是个很好的选择。</p><p>不适用场景：</p><p>1.取代通过键查询，而是通过值来查询。Key-Value数据库中根本没有通过值查询的途径</p><p>2.需要储存数据之间的关系。在Key-Value数据库中不能通过两个或以上的键来关联数据。</p><p>3.事务的支持。在Key-Value数据库中故障产生时不可以进行回滚。</p><h3 id="文档型（Document-Oriented）数据库-MongoDB-ES"><a href="#文档型（Document-Oriented）数据库-MongoDB-ES" class="headerlink" title="文档型（Document-Oriented）数据库[MongoDB] ES"></a>文档型（Document-Oriented）数据库[MongoDB] ES</h3><p>数据可以使用XML、<strong>JSON</strong>或者JSONB等多种形式存储。 {“name”:“abc”}</p><p>适用场景：1.日志 2.分析</p><p>不适用场景：不支持事务</p><h3 id="列存储（Wide-Column-Store-x2F-Column-Family）数据库-HBASE"><a href="#列存储（Wide-Column-Store-x2F-Column-Family）数据库-HBASE" class="headerlink" title="列存储（Wide Column Store&#x2F;Column-Family）数据库[HBASE]"></a>列存储（Wide Column Store&#x2F;Column-Family）数据库[HBASE]</h3><p>列存储数据库将数据储存在列族（column family）中，一个列族存储经常被一起查询的相关数据。举个例子，如果我们有一个Person类，我们通常会一起查询他们的姓名和年龄而不是薪资。这种情况下，姓名和年龄就会被放入一个列族中，而薪资则在另一个列族中。</p><p>适用场景：1.日志 2.博客平台,我们储存每个信息到不同的列族中。举个例子，标签可以储存在一个，类别可以在一个，而文章则在另一个。</p><p>不适用场景：1.ACID事务 2.原型设计。在模型设计之初，我们根本不可能去预测它的查询方式，而一旦查询方式改变，我们就必须重新设计列族。</p><h3 id="图（Graph-Oriented）数据库-Neo4J-infoGird"><a href="#图（Graph-Oriented）数据库-Neo4J-infoGird" class="headerlink" title="图（Graph-Oriented）数据库[Neo4J,infoGird]"></a>图（Graph-Oriented）数据库[Neo4J,infoGird]</h3><p>适用范围很小，主要用用网络拓扑分析 如脉脉的人员关系图等</p><h2 id="常见的NoSql数据库"><a href="#常见的NoSql数据库" class="headerlink" title="常见的NoSql数据库"></a>常见的NoSql数据库</h2><p><img src="https://raw.githubusercontent.com/quhuiya/properties/main/imgimage-20220620163054988.png" alt="image-20220620163054988">  </p><h2 id="总结NoSql"><a href="#总结NoSql" class="headerlink" title="总结NoSql"></a>总结NoSql</h2><ol><li>NoSql就是为了性能而诞生的</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">指的是NoSql的读写性能非常的高 因为是将数据存放在内存中的</span><br></pre></td></tr></table></figure><ol><li>NoSql是Sql的阉割版本，是为了解决行业内特定问题</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NoSql基本都是配置关系型数据库使用</span><br></pre></td></tr></table></figure><ol><li><p>NoSql没有特定的数据结构定义，使用时不需要表</p></li><li><p>NoSql对事物的支持很差：在Key-Value数据库中故障产生时不可以进行回滚。 </p></li><li><p>只能通过值查询</p><hr></li></ol><h1 id="Redis数据库的介绍"><a href="#Redis数据库的介绍" class="headerlink" title="Redis数据库的介绍"></a>Redis数据库的介绍</h1><p>Remote Dictionary Server 远程字典服务器</p><p>Redis以key-value形式操作数据库，数据存放在内存中</p><p>支持持久化：</p><p>​1. rdb     周期性的将存放的数据写磁盘文件</p><p>​2. aof     将对redis的所有写操作指令记录到磁盘文件</p><h2 id="Redis的特点"><a href="#Redis的特点" class="headerlink" title="Redis的特点"></a>Redis的特点</h2><p>redis的读取速度：110000次&#x2F;秒   写速度：81000次&#x2F;秒</p><p>为什么快</p><ul><li>单线程不需要线程切换开销，</li><li>没有锁的竞争，</li><li>多路复用</li></ul><h2 id="支持多种数据类型："><a href="#支持多种数据类型：" class="headerlink" title="支持多种数据类型："></a>支持多种数据类型：</h2><ul><li>string </li><li>list </li><li>hash </li><li>set </li><li>zset</li><li>。。。</li></ul><p>支持就持久化   主从复制   集群</p><hr><h2 id="Redis的应用场景"><a href="#Redis的应用场景" class="headerlink" title="Redis的应用场景"></a>Redis的应用场景</h2><h3 id="数据缓存（提高访问性能）"><a href="#数据缓存（提高访问性能）" class="headerlink" title="数据缓存（提高访问性能）"></a>数据缓存（提高访问性能）</h3><p>将一些数据在短时间之内不会发生变化，而且它们还要被频繁访问，为了提高用户的请求速度和降低网站的负载，降低数据库的读写次数，就把这些数据放到缓存中。</p><h3 id="会话缓存（共享session）"><a href="#会话缓存（共享session）" class="headerlink" title="会话缓存（共享session）"></a>会话缓存（共享session）</h3><p>（session cache，保存web会话信息）</p><h3 id="排行榜-x2F-计数器"><a href="#排行榜-x2F-计数器" class="headerlink" title="排行榜&#x2F;计数器"></a>排行榜&#x2F;计数器</h3><p>（NGINX+lua+redis计数器进行IP自动封禁）</p><h3 id="消息队列（ActiveMQ-x2F-RabbitMQ-x2F-Kafka-x2F-RocketMQ）"><a href="#消息队列（ActiveMQ-x2F-RabbitMQ-x2F-Kafka-x2F-RocketMQ）" class="headerlink" title="消息队列（ActiveMQ&#x2F;RabbitMQ&#x2F;Kafka&#x2F;RocketMQ）"></a>消息队列（ActiveMQ&#x2F;RabbitMQ&#x2F;Kafka&#x2F;RocketMQ）</h3><p>（构建实时消息系统，聊天，群聊）</p><p><strong>重点做缓存（数据，用户信息）</strong></p><h1 id="redis的安装与配置"><a href="#redis的安装与配置" class="headerlink" title="redis的安装与配置"></a>redis的安装与配置</h1><ul><li><strong>安装gcc  目地是编译软件</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install gcc-c++ </span><br></pre></td></tr></table></figure><ul><li><strong>解压安装包</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf redis-5.0.7.tar.gz</span><br></pre></td></tr></table></figure><ul><li><strong>把解压的文件copy到&#x2F;usr&#x2F;local&#x2F;src里面进行配置</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp -r /root/software/redis-5.0.7 /usr/local/src/redis</span><br></pre></td></tr></table></figure><ul><li><strong>打开&#x2F;usr&#x2F;local&#x2F;src&#x2F;redis&#x2F;deps进行编译依赖项</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">进入redis的deps目录下</span><br><span class="line">cd /usr/local/src/redis/deps</span><br><span class="line">编辑依赖</span><br><span class="line">make hiredis lua jemalloc linenoise</span><br><span class="line">进入redis目录下</span><br><span class="line">cd /usr/local/src/redis</span><br><span class="line">执行配置命令</span><br><span class="line">make</span><br></pre></td></tr></table></figure><ul><li><strong>将配置完成的软件安装到&#x2F;usr&#x2F;local&#x2F;redis里面</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">创建文件夹</span><br><span class="line">mkdir  -p /usr/local/redis</span><br><span class="line">进行安装</span><br><span class="line">make install PREFIX=/usr/local/redis</span><br></pre></td></tr></table></figure><p>​看到次界面则表示安装成功</p><p><img src="https://raw.githubusercontent.com/quhuiya/properties/main/imgimage-20220618195457485.png" alt="image-20220618195457485"> </p><ul><li><strong>验证是否成功</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/redis/bin</span><br><span class="line">ls</span><br></pre></td></tr></table></figure><p>看到如下启动文件就可以了</p><p><img src="https://raw.githubusercontent.com/quhuiya/properties/main/imgimage-20220618195634000.png" alt="image-20220618195634000"> </p><ul><li><strong>把配置文件移动到&#x2F;usr&#x2F;local&#x2F;redis&#x2F;conf目录</strong></li></ul><blockquote><p>创建目录</p><p>mkdir &#x2F;usr&#x2F;local&#x2F;redis&#x2F;conf</p><p>复制</p><p>cp &#x2F;usr&#x2F;local&#x2F;src&#x2F;redis&#x2F;redis.conf &#x2F;usr&#x2F;local&#x2F;redis&#x2F;conf </p></blockquote><ul><li><strong>启动Redis</strong></li></ul><blockquote><p>进入软件启动文件位置</p><p>cd &#x2F;usr&#x2F;local&#x2F;redis&#x2F;bin </p><p>启动软件（指定配置文件）</p><p>.&#x2F;redis-server &#x2F;usr&#x2F;local&#x2F;redis&#x2F;conf&#x2F;redis.conf</p></blockquote><p>看见下图则表示启动成功</p><p><img src="https://raw.githubusercontent.com/quhuiya/properties/main/imgimage-20220618195706158.png" alt="image-20220618195706158"> </p><ul><li><strong>默认情况，Redis是不能在后台运行，我们需要把redis放在后台运行</strong></li></ul><blockquote><p>更改配置文件</p><p> vi &#x2F;usr&#x2F;local&#x2F;redis&#x2F;conf&#x2F;redis.conf</p></blockquote><p><img src="https://raw.githubusercontent.com/quhuiya/properties/main/imgimage-20220618195738262.png" alt="image-20220618195738262"> </p><ul><li><strong>退出redis并重启</strong></li></ul><blockquote><p>退出</p><p>cd &#x2F;usr&#x2F;local&#x2F;redis&#x2F;bin<br>.&#x2F;redis-cli shutdown</p><p>或者</p><p>ps -ef|grep redis    </p><p>kill -9 进程号 </p><p>启动</p><p>.&#x2F;redis-server &#x2F;usr&#x2F;local&#x2F;redis&#x2F;conf&#x2F;redis.conf </p><p>查看进程</p><p>ps -ef|grep redis</p></blockquote><p><img src="https://raw.githubusercontent.com/quhuiya/properties/main/imgimage-20220618195802533.png" alt="image-20220618195802533"> </p><p>可以看到在6379端口号已启动了</p><h2 id="客户端连接与退出"><a href="#客户端连接与退出" class="headerlink" title="客户端连接与退出"></a>客户端连接与退出</h2><ul><li>连接：</li></ul><blockquote><p>.&#x2F;redis-cli<br>其实相当于进入本机的redis服务器   .&#x2F;redis-cli -h 127.0.0.1 -p 6379 同时默认进入的数据库为 0 数据库（有0~15）<br>如果连接的redis不是本机的或者端口号不是6379 则需要使用-h（ip）或者-p（端口）<br>在进入客户端后，测试连接是否成功： <code>ping</code>  如果响应 <code>PONG</code>  表示发送数据与接收数据成功</p></blockquote><ul><li>退出客户端：</li></ul><blockquote><p>exit</p></blockquote><h2 id="退出服务端"><a href="#退出服务端" class="headerlink" title="退出服务端"></a>退出服务端</h2><p>链接客户端的退出只是指退出操作界面；此退出表示退出服务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">标准退出：退出服务器，在客户端使用指令 `shutdown`</span><br><span class="line"></span><br><span class="line">强制退出： kill -9 redid的进程号</span><br></pre></td></tr></table></figure><h2 id="设置redis开机自启"><a href="#设置redis开机自启" class="headerlink" title="设置redis开机自启"></a>设置redis开机自启</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/rc.local</span><br><span class="line">加入redis的绝对路径</span><br><span class="line">/usr/local/redis/bin/redis-server /usr/local/redis/conf/redis.conf</span><br></pre></td></tr></table></figure><h2 id="bin文件介绍"><a href="#bin文件介绍" class="headerlink" title="bin文件介绍"></a>bin文件介绍</h2><p>redis-server   redis服务器的启动程序</p><p>redis-cli          redis客户端的启动程序</p><p>redis-rdb       与redis的rdb持久化方案相关的程序（定时）</p><p>redis-aof       与redis的aof持久化方案相关的程序（监视）</p><p>redis-benchmark  redis的压力测试工具</p><p>redis-sentinel       redis的哨兵模式程序</p><h1 id="配置长参数详解"><a href="#配置长参数详解" class="headerlink" title="配置长参数详解"></a>配置长参数详解</h1><table><thead><tr><th align="center">daemonize：</th><th align="left">如需要在后台运行，把该项的值改为yes</th></tr></thead><tbody><tr><td align="center">pdifile：</td><td align="left">把pid文件放在&#x2F;var&#x2F;run&#x2F;redis.pid，可以配置到其他地址</td></tr><tr><td align="center">bind：</td><td align="left">指定redis只接收来自该IP的请求，如果不设置，那么将处理所有请求，在生产环节中最好设置该项</td></tr><tr><td align="center">port：</td><td align="left">监听端口，默认为6379</td></tr><tr><td align="center">timeout：</td><td align="left">设置客户端连接时的超时时间，单位为秒</td></tr><tr><td align="center">loglevel：</td><td align="left">等级分为4级，debug，revbose，notice和warning。生产环境下一般开启notice</td></tr><tr><td align="center">logfile：</td><td align="left">配置log文件地址，默认使用标准输出，即打印在命令行终端的端口上</td></tr><tr><td align="center">database：</td><td align="left">设置数据库的个数，默认使用的数据库是0</td></tr><tr><td align="center">save：</td><td align="left">设置redis进行数据库镜像的频率</td></tr><tr><td align="center">rdbcompression：</td><td align="left">在进行镜像备份时，是否进行压缩</td></tr><tr><td align="center">dbfilename：</td><td align="left">镜像备份文件的文件名</td></tr><tr><td align="center">dir：</td><td align="left">数据库镜像备份的文件放置的路径</td></tr><tr><td align="center">slaveof：</td><td align="left">设置该数据库为其他数据库的从数据库</td></tr><tr><td align="center">masterauth：</td><td align="left">当主数据库连接需要密码验证时，在这里设定</td></tr><tr><td align="center">requirepass：</td><td align="left">设置客户端连接后进行任何其他指定前需要使用的密码</td></tr><tr><td align="center">maxclients：</td><td align="left">限制同时连接的客户端数量</td></tr><tr><td align="center">maxmemory：</td><td align="left">设置redis能够使用的最大内存</td></tr><tr><td align="center">appendonly：</td><td align="left">开启appendonly模式后，redis会把每一次所接收到的写操作都追加到appendonly.aof文件中，当redis重新启动 时，会从该文件恢复出之前的状态</td></tr><tr><td align="center">appendfsync：</td><td align="left">设置appendonly.aof文件进行同步的频率</td></tr><tr><td align="center">vm_enabled：</td><td align="left">是否开启虚拟内存支持</td></tr><tr><td align="center">vm_swap_file：</td><td align="left">设置虚拟内存的交换文件的路径</td></tr><tr><td align="center">vm_max_momery：</td><td align="left">设置开启虚拟内存后，redis将使用的最大物理内存的大小，默认为0</td></tr><tr><td align="center">vm_page_size：</td><td align="left">设置虚拟内存页的大小</td></tr><tr><td align="center">vm_pages：</td><td align="left">设置交换文件的总的page数量</td></tr><tr><td align="center">vm_max_thrrads：</td><td align="left">设置vm IO同时使用的线程数量</td></tr></tbody></table><h1 id="常见命令"><a href="#常见命令" class="headerlink" title="常见命令"></a>常见命令</h1><table><thead><tr><th align="center">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="center">keys *</td><td align="left">查询当前数据中所有的key</td></tr><tr><td align="center">select index</td><td align="left">切换数据库 （在进入redis客服端后使用，redis服务器默认有16个数据库[0~15]）</td></tr><tr><td align="center">flushdb</td><td align="left">清空当前数据库</td></tr><tr><td align="center">flshall</td><td align="left">清空所有数据库</td></tr><tr><td align="center">del key</td><td align="left">删除指定key对应的数据</td></tr><tr><td align="center">expire key 10</td><td align="left">设置指定key对应的数据的过期时间</td></tr><tr><td align="center">pexpire key 1000</td><td align="left">设置key的过期时间单位是毫秒</td></tr><tr><td align="center">persist key</td><td align="left">删除过期时间</td></tr><tr><td align="center">ttl key</td><td align="left">查看指定key对应数据的过期时间。  -1：表示没有过期时间  -2：表示已经过期</td></tr><tr><td align="center">type key</td><td align="left">类型</td></tr><tr><td align="center">exists key</td><td align="left">判断是否存在key</td></tr></tbody></table><h1 id="操作不同的数据类型"><a href="#操作不同的数据类型" class="headerlink" title="操作不同的数据类型"></a>操作不同的数据类型</h1><h2 id="string类型的数据"><a href="#string类型的数据" class="headerlink" title="string类型的数据"></a>string类型的数据</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">set key value  存放key-vulue </span><br><span class="line">get key  获取key的值</span><br><span class="line">getset name new_cxx 设置值，返回旧值</span><br><span class="line">mset key1 v1 key2 v2 批量设置</span><br><span class="line">mget key1 key2 批量获取</span><br><span class="line">setnx key value 不存在就插入（set if not exists） 分布式锁</span><br><span class="line">incr age 递增</span><br><span class="line">incrby age 10 递增</span><br><span class="line">decr age 递减</span><br><span class="line">decrby age 10 递减</span><br><span class="line">strlen 长度</span><br><span class="line">getrange name 0 -1 字符串分段   0 -1是全部   0 -2  ==n-1</span><br><span class="line">setrange key index value 从index开始替换value</span><br><span class="line">incrbyfloat 增减浮点数</span><br><span class="line">append 追加</span><br><span class="line">object encoding key  得到key 的类型  string里面有三种编码</span><br><span class="line">int  用于能够作用64位有符号整数表示的字符串</span><br><span class="line">embstr 用于长度小于或等于44字节  Redis3.x中是39字节，这种类型的编码在内存使用  时性能更好</span><br><span class="line">raw  用于长度大于44字节的</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="list类型的数据"><a href="#list类型的数据" class="headerlink" title="list类型的数据"></a>list类型的数据</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">lpush key  values    l=left    r =rigth     </span><br><span class="line">lpush mylist a b c 左插入</span><br><span class="line">    rpush mylist x y z 右插入</span><br><span class="line">    lrange mylist 0 -1 取出数据集合  0 -1是取出所有   0   1取第一个和第二个</span><br><span class="line">    lpop mylist 弹出集合最后一个元素  弹出之后就没有了哦</span><br><span class="line">    rpop mylist 弹出第一个元素  弹出之后就没有了哦</span><br><span class="line">    lrem mylist count value 删除</span><br><span class="line">        |-COUNT 的值可以是以下几种：</span><br><span class="line">            |--count &gt; 0 : 从表头开始向表尾搜索，移除与 VALUE 相等的元素，数量为 COUNT 。</span><br><span class="line">            |--count &lt; 0 : 从表尾开始向表头搜索，移除与 VALUE 相等的元素，数量为 COUNT 的绝对值。</span><br><span class="line">            |--count = 0 : 移除表中所有与 VALUE 相等的值。</span><br><span class="line">    lindex mylist 2 指定索引的值</span><br><span class="line">    llen mylist 长度  </span><br><span class="line">    lset mylist 2 n 索引设值</span><br><span class="line">    ltrim mylist 0 4   </span><br><span class="line">            |--对一个列表进行修剪(trim)，就是说，让列表只保留指定区间内的元素，不在指定区间之内的元素都将被删除。</span><br><span class="line">下标 0 表示列表的第一个元素，以 1 表示列表的第二个元素，以此类推。 </span><br><span class="line">你也可以使用负数下标，以 -1 表示列表的最后一个元素， -2 表示列表的倒数第二个元素，以此类推。</span><br><span class="line">    linsert mylist before a 插入</span><br><span class="line">    linsert mylist after a 插入</span><br><span class="line">            |--命令用于在列表的元素前或者后插入元素。 当指定元素不存在于列表中时，不执行任何操作。 </span><br><span class="line">当列表不存在时，被视为空列表，不执行任何操作。 如果 key 不是列表类型，返回一个错误。</span><br><span class="line">    rpoplpush list list2 转移列表的数据</span><br><span class="line">            |--命令用于移除列表的最后一个元素，并将该元素添加到另一个列表并返回。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NoSQL </tag>
            
            <tag> 软件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo+github搭建个人博客</title>
      <link href="/post/68689ca1.html"/>
      <url>/post/68689ca1.html</url>
      
        <content type="html"><![CDATA[<ul><li><p>sadfhsdsdfsdfsd</p><blockquote><p>sdfsdfsdfds</p><p>fsdfsdfsdfsdlkf</p><blockquote><p>sdfsdf ‘dsfsd</p></blockquote></blockquote></li></ul><p><code>fsdfas</code> (sdfsdsdfsd) </p><table><thead><tr><th align="center">sdfjl</th><th align="center">sdfhjsdal</th><th></th><th></th><th></th></tr></thead><tbody><tr><td align="center">fsdfsdfsdfsdf</td><td align="center">sdfh</td><td></td><td></td><td></td></tr><tr><td align="center"></td><td align="center"></td><td></td><td></td><td></td></tr><tr><td align="center"></td><td align="center"></td><td></td><td></td><td></td></tr><tr><td align="center"></td><td align="center"></td><td></td><td></td><td></td></tr><tr><td align="center"></td><td align="center"></td><td></td><td></td><td></td></tr><tr><td align="center"></td><td align="center"></td><td></td><td></td><td></td></tr></tbody></table><p>| 士大夫发射点 | 士大夫撒旦 |<br>|||<br>||</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">​```mermaid</span><br><span class="line">graph LR</span><br><span class="line">A[方形] --&gt;B(圆角)</span><br><span class="line">    B --&gt; C&#123;条件a&#125;</span><br><span class="line">    C --&gt;|a=1| D[结果1]</span><br><span class="line">    C --&gt;|a=2| E[结果2]</span><br><span class="line">    F[横向流程图]</span><br><span class="line">​```</span><br></pre></td></tr></table></figure><p>速度发货速度</p><hr><blockquote><p>而发生</p></blockquote><ul><li>士大夫胜多负少</li></ul><ol><li>撒旦发射点发射点</li><li><ul><li>大师傅士大夫撒旦</li></ul></li></ol><p><code>dfsfjdskl jljdlsfjkld</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">士大夫但是速度加快fsdfsda</span><br><span class="line">sdfsd sdfsdf sdf sd sdfsdgasdgasd </span><br><span class="line">sdfsad sdfsd sda </span><br><span class="line">sdfgasd sdf </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 测试 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
